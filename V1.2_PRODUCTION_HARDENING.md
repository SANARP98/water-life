# RandomScalp.py v1.2 - Production Hardening

## Overview
v1.2 addresses real-world trading edge cases identified during comprehensive production audit. All changes are non-breaking and backward-compatible, implementing defensive programming patterns for volatile trading sessions with cranky brokers.

---

## Production Edge Cases Fixed

### 1. **Partial Fill Handling on Entry** ([randomScalp.py:831-902](randomScalp.py#L831-902))

**Problem:** Market entry orders can partially fill. If you request 150 qty but get 75, placing exit legs for 150 creates excess short position.

**Fix:**
- Added `actual_filled_qty` tracking separate from requested `self.qty`
- Poll `orderstatus()` for `filled_quantity` field (supports multiple field names for compatibility)
- Only place exit legs for `actual_filled_qty`
- Log partial fills: `[PARTIAL_FILL] Entry filled 75/150 @ ₹100.50`

**Code:**
```python
filled_qty = self._get_filled_qty(st)
if filled_qty < self.qty:
    log(f"[PARTIAL_FILL] Entry filled {filled_qty}/{self.qty}")
self.actual_filled_qty = filled_qty
self.place_exit_legs_for_qty(self.actual_filled_qty)
```

---

### 2. **Idempotent Order Placement** ([randomScalp.py:455-481](randomScalp.py#L455-481))

**Problem:** Network timeouts can cause order submission failures. Retrying blindly creates duplicate orders.

**Fix:**
- New `_safe_placeorder()` wrapper with retry logic
- Max attempts: configurable via `MAX_ORDER_RETRIES` (default: 2)
- Progressive backoff: 0.3s × (attempt + 1)
- On timeout, detects if order actually went through before retrying
- Returns `None` on failure instead of raising exceptions

**Code:**
```python
resp = self._safe_placeorder(
    strategy=STRATEGY_NAME,
    symbol=self.cfg.symbol,
    ...
)
if not resp or resp.get('status') != 'success':
    # Handle gracefully
```

---

### 3. **SL-M Trigger Validation & Fallback** ([randomScalp.py:483-535](randomScalp.py#L483-535))

**Problem:** Many brokers reject SL-M orders when:
1. Trigger price is wrong side of LTP (e.g., trigger >= LTP for long)
2. SL-M not supported for instrument type

**Fix:**
- New `_place_stop_order()` method with smart logic:
  1. Validates trigger_price < LTP before SL-M placement (long case)
  2. Auto-adjusts trigger to `LTP - tick` if invalid
  3. Tries SL-M first
  4. Falls back to SL (with price = trigger - tick) if SL-M fails
- Comprehensive logging for debugging

**Code:**
```python
if ltp and trigger_price >= ltp:
    log(f"[WARN] SL trigger {trigger_price:.2f} >= LTP {ltp:.2f}, adjusting")
    trigger_price = max(self._round_to_tick(ltp - self.tick_size), 0.05)
```

---

### 4. **Partial Exit Fill Synchronization** ([randomScalp.py:537-584](randomScalp.py#L537-584))

**Problem:** If TP fills 50/75 and SL is still open for 75, you have asymmetric protection (SL too large).

**Fix:**
- Track `tp_filled_qty` and `sl_filled_qty` separately
- In `check_order_status()`, detect partial fills via `_is_partial()`
- Calculate `remaining_qty = actual_filled_qty - (tp_filled_qty + sl_filled_qty)`
- Call `_sync_exit_quantities(remaining_qty)` to cancel and re-place both exits with correct quantity
- Prevents over-exit and position flips

**Code:**
```python
total_exits = self.tp_filled_qty + self.sl_filled_qty
if total_exits > 0 and total_exits < self.actual_filled_qty:
    remaining_qty = self.actual_filled_qty - total_exits
    self._sync_exit_quantities(remaining_qty)
```

---

### 5. **Three-Axis Reconciliation** ([randomScalp.py:669-737](randomScalp.py#L669-737))

**Problem:** Previous reconciliation only checked quantity. Missing direction and price validation.

**Fix:**
- Enhanced `reconcile_position()` to compare:
  1. **Direction:** flat vs long
  2. **Quantity:** expected vs actual
  3. **Avg Price:** internal vs broker's avg_price
- Use broker's avg_price if internal state missing
- Immediately call `_ensure_exits()` if position detected without exit orders
- Call `_cleanup_stale_orders()` if flat with orphaned orders

**Benefits:**
- Detects externally closed positions
- Recovers from missing exit protection
- Validates P&L calculation accuracy

---

### 6. **Child Order Cleanup** ([randomScalp.py:586-596](randomScalp.py#L586-596))

**Problem:** Stale TP/SL orders remain after position closed, causing confusion and wasted API calls.

**Fix:**
- New `_cleanup_stale_orders()` method
- Called during reconciliation if flat
- Cancels any orphaned TP/SL orders
- Nils order IDs and resets filled quantities
- Prevents retry loops on rejected orders

---

### 7. **Enhanced Graceful Exit with Escalation** ([randomScalp.py:1231-1318](randomScalp.py#L1231-1318))

**Problem:** Previous shutdown sent MARKET and waited 5s. If order stuck, position remains open after exit.

**Fix:**
- **Phase 1:** Poll every 0.25s for 5s (20 iterations) for confirmation
- **Phase 2:** If not confirmed, retry MARKET order once
- **Phase 3:** Keep process alive 30 more seconds with `reconcile_position()` running
- **Phase 4:** Log CRITICAL alert if still in position after all attempts
- Uses `actual_filled_qty` for close quantity (handles partial entry fills)

**Escalation Protocol:**
```
0.25s poll × 20 → retry MARKET → 30s keep-alive → CRITICAL alert
```

---

### 8. **Market-on-Target** ([randomScalp.py:806-827](randomScalp.py#L806-827))

**Problem:** Gap opening past TP LIMIT means no prints at that price → order never fills even though target reached.

**Fix:**
- Optional feature via `ENABLE_MARKET_ON_TARGET` config (default: false)
- In `check_order_status()`, check if `LTP >= TP`
- If true, cancel both exits and send MARKET for remaining quantity
- Ensures profit-taking even on gaps

**Use Case:** Options/futures with price discontinuities

---

### 9. **Enhanced Logging with State Summaries** ([randomScalp.py:896](randomScalp.py#L896))

**Problem:** Difficult to grep logs for current state during debugging.

**Fix:**
- Added one-line state summaries after key events:
  ```
  STATE=LONG qty=75 entry=100.50 tp=102.50 sl=99.50
  ```
- Critical warnings for unprotected positions:
  ```
  [CRITICAL] TP rejected - position UNPROTECTED on upside!
  ```
- Detailed partial fill logging with quantities

---

### 10. **Helper Methods for Reusability**

**New Methods:**
- `_safe_placeorder(**params)` - idempotent placement
- `_place_stop_order(qty, trigger, action)` - SL-M with fallback
- `_sync_exit_quantities(remaining_qty)` - partial fill sync
- `_cleanup_stale_orders()` - orphan removal
- `_ensure_exits()` - re-arm missing protection
- `_is_partial(resp)` - detect partial fills
- `_get_filled_qty(resp)` - extract filled quantity
- `place_exit_legs_for_qty(quantity)` - quantity-aware exits

---

## New Configuration Parameters

```env
# Production Hardening (v1.2)
API_TIMEOUT_SECONDS=10          # Timeout for API calls
MAX_ORDER_RETRIES=2             # Max retry attempts for orders
ENABLE_MARKET_ON_TARGET=false   # Convert TP to MARKET on gap
```

---

## State Variables Added

```python
self.actual_filled_qty: int = 0       # Actual filled (may differ from requested)
self.tp_filled_qty: int = 0           # Track partial TP fills
self.sl_filled_qty: int = 0           # Track partial SL fills
```

---

## Testing Scenarios

### 1. **Partial Entry Fill**
- Request 150 qty, broker fills 75
- Verify exits placed for 75 only
- Check state: `actual_filled_qty = 75`

### 2. **SL-M Rejection**
- Force SL-M failure (unsupported instrument)
- Verify auto-fallback to SL
- Check trigger validation logic

### 3. **Timeout Retry**
- Simulate network timeout on placeorder
- Verify max 2 retries with backoff
- Ensure no duplicate orders

### 4. **Partial Exit Sync**
- TP fills 50/75, SL open for 75
- Verify SL cancelled and re-placed for 25
- Check `tp_filled_qty` tracking

### 5. **Graceful Exit Escalation**
- SIGTERM with position
- First MARKET hangs (simulate)
- Verify retry MARKET → 30s keep-alive
- Check CRITICAL alert if still open

### 6. **Market-on-Target**
- Enable `ENABLE_MARKET_ON_TARGET=true`
- Gap opening: LTP jumps from 100 → 105 (TP at 102)
- Verify TP converts to MARKET

### 7. **Three-Axis Reconciliation**
- Manually close position at broker
- Wait for reconciliation (max 30s)
- Verify internal state updated to flat

---

## Performance Impact

- **Minimal overhead:** New checks run in existing polling loops
- **Network calls:** Same as v1.1 (no additional API calls under normal operation)
- **Memory:** +3 int fields per instance (~24 bytes)
- **Graceful exit:** +30s max in worst-case scenario (acceptable for safety)

---

## Migration from v1.1

**No breaking changes.** Simply update the code:

```bash
git pull
# Or copy new randomScalp.py
python randomScalp.py  # Works with existing .env
```

**Optional:** Add new config params to `.env` for customization.

---

## Production Readiness Checklist

- [x] Partial fill handling (entry + exits)
- [x] Idempotent order placement
- [x] SL-M trigger validation & fallback
- [x] Partial exit quantity sync
- [x] Three-axis reconciliation
- [x] Child order cleanup
- [x] Enhanced graceful exit with escalation
- [x] Market-on-target (optional)
- [x] Comprehensive logging
- [x] Backward compatibility
- [x] Documentation updated

---

## Known Limitations

1. **No GTT/AMO support:** Orders are regular intraday orders
2. **Long-only:** No short position logic
3. **Single instrument:** One symbol per bot instance
4. **No bracket orders:** OCO emulated via polling (broker-dependent)

---

## Next Steps for Production

1. **Run in simulator mode:** `TEST_MODE=true` for 1 week
2. **Paper trade:** Live data, no real orders (if supported)
3. **Start small:** 1 lot on low-volatility instrument
4. **Monitor logs:** Watch for CRITICAL/WARN messages
5. **Scale gradually:** Increase lots after 1 month of stable operation

---

## Support & Issues

- **Bugs:** Report at project issue tracker
- **Questions:** OpenAlgo Discord: https://openalgo.in/discord
- **Docs:** https://docs.openalgo.in

---

**Version:** 1.2
**Date:** 2025-01-XX
**Author:** Random Scalp Port
**License:** As per parent project
